// INTAKE one talon for feeding one neo for  pivot
// SHOOTER one neo for shooting, one neo for pivot, one talon for conveyer belt

//create enums, expecting, holding, firing, and no note

package frc.robot.subsystems;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

//enum, change decleration location later
enum robotState {
    LOADING_NOTE, //taken through intake
    HOLDING_NOTE, //in the conveyer belt
    NO_NOTE, //no note in robot
    FIRING
}

public class ShooterSubsystem extends SubsystemBase {

    //change later
    int IDNUMBER = 10; //so I remember to change them later
    double speed = 0.1; 
    int final ERRORTOLERANCE = 10;
    int final LIMIT_SWITCH_ID = 1;
    int final GEARBOX_RATIO = 1/20;

    //angle PID (CHANGE LATER)
    private static final double angleP = 2.4;
    private static final double angleI = 0;
    private static final double angleD = 0;

    //motors
    private final WPI_TalonSRX conveyerBelt; 
    private final CANSparkMax pivotMotor;
    private final CANSparkMax shooterMotor;

    //devices
    private RelativeEncoder rotationEncoder;
    private SparkMaxPIDController rotationPidController;
    private final DigitalInput limitSwitch;
    private robotState currentState;

    //sensors
    private final AnalogPotentiometer shooterSensor; //distance sensor

    public ShooterSubsystem(){
        //motors
        conveyerBelt = new WPI_TalonSRX(10);
        pivotMotor = new CANSparkMax(10, MotorType.kBrushed);
        shooterMotor = new CANSparkMax(10, MotorType.kBrushed);

        //devices
        rotationEncoder = pivotMotor.getEncoder();
        rotationPIDController = pivotMotor.getPIDController();
        limitSwitch = new DigitalInput(LIMIT_SWITCH_ID);
        
        //setting PID vars
        rotationPIDController.setP(extensionP);
        rotationPIDController.setI(extensionI);
        rotationPIDController.setD(extensionD);

        //encoder stuff
        rotationEncoder.setPositionConversionFactor(GEARBOX_RATIO);

        //enums
        state = robotState.NO_NOTE;

        rotationPIDController.setSmartMotionAllowedClosedLoopError(ERRORTOLERANCE, 0); //what does 0 do (slotID is from 0-3)
    }

    //enum functions
    public robotState getShooterState(robotState state){
        return currentState;
    }

    public robotState setShooterState(robotState newState){
        currentState = newState;
    }

    public shootNote(){
        if(shooterSensor.get() < tolerance){
            conveyerBelt.set(speed);
            setShooterState(robotState.FIRING);
        } else {
            shooterMotor.set(0);
            conveyerBelt.set(speed);
        }
    }

    public setAngle(double angle){
        rotationEncoder.setPosition(angle);
    }

    public void periodic(){
        //resets relative encoder every time robot starts again
        if(limitSwitch != null && !limitSwitch.get()){ //false = limit switch is pressed
            rotationEncoder.setPosition(0); 
        }

        if(currentState == FIRING && (shooterSensor.get() < tolerance)){  //when there is no note
            setShooterState(robotState.NO_NOTE);
        }

        // switch(currentState) {
        //     case HOLDING_NOTE:
        //       shooterMotor.set(speed); //warming up the motor
        //       break;
        //     case LOADING_NOTE:
        //        shooterMotor.set(speed);
        //        shootNote();
        //       break;
        //     case NO_NOTE:
        //       System.out.println("High level");
        //       break;
        // }

    }
}